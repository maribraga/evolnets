#' Posterior distribution of network structure indices across ancestral networks
#'
#' Calculate z-scores for nestedness (NODF) or modularity (Q) for each MCMC sample at time points in
#' the past based on null networks where all interactions have the same probability. By calculating
#' z-scores, we can compare ancestral networks at different ages.
#'
#' @param sampled_networks List of ancestral networks sampled across MCMC at given ages. Usually from
#'   the output of `get_sampled_networks`, see example.
#' @param index Index to be calculated for each ancestral network. "NODF" to calculate nestedness or
#'   "Q" to calculate modularity.
#' @param ages Vector of ages (time points in the past) of ancestral networks. By default, uses all
#'   ages present in `sampled_networks`.
#' @param nnull Number of null networks to generate to calculate the z-score. Default is 100.
#'
#' @return A data.frame of z-scores and p-values across samples and ages.
#' @importFrom magrittr %>%
#' @importFrom methods is slot
#' @export
#'
#' @examples
#' data(tree)
#' data(host_tree)
#' data(history)
#'
#' ages <- c(60,50,40,0)
#' samples_at_ages <- posterior_at_ages(history, ages, tree, host_tree)
#' sampled_networks <- get_sampled_networks(samples_at_ages)
#'
#' # calculate posterior distribution of nestedness
#' Nz <- index_at_ages(sampled_networks, index = "NODF")
#'
#' #  calculate posterior distribution of modularity (SLOW!)
#' # Qz <- index_at_ages(sampled_networks, index = "Q")
index_at_ages <- function(sampled_networks, index, ages = NULL, nnull = 100){

  # Input checking
  if (!is.list(sampled_networks)) {
    stop('`sampled_networks` should be a list, usually generated by `posterior_at_ages`.')
  }
  if (!(all(vapply(sampled_networks, is.array, TRUE)))) {
    stop('All list entries of `sampled_networks` should be arrays. Make sure you are only passing ',
         'the `samples` part of the `posterior_at_ages` output.')
  }
  index <- match.arg(index, c('NODF', 'Q'), several.ok = FALSE)
  if (!is.null(ages) & !is.numeric(ages)) stop('`ages` should be numeric.')
  if (!is.numeric(nnull)) stop('`nnull` should be numeric.')

  if (is.null(ages)) ages <- as.numeric(names(sampled_networks))

  # Keep only specified ages
  sampled_networks <- sampled_networks[as.character(ages)]

  # Calculating indices
  if (index == "NODF") {
    # find unique values, to check for three-state model.
    unique_vals <- Reduce(union, lapply(sampled_networks, function(x) unique(c(x))))
    three_state <- identical(sort(unique_vals), 0:2)

    NODF_null <- NODF_samples_null(sampled_networks, ages, nnull, weighted = three_state)
    NODF_samples <- NODF_samples_at_ages(sampled_networks, ages, weighted = three_state)

    NODF_pvals <- NODF_null %>%
      dplyr::filter(!is.na(NODFnull)) %>%
      dplyr::left_join(NODF_samples, by = c("age", "sample")) %>%
      dplyr::group_by(.data$age, .data$sample) %>%
      dplyr::summarise(p = sum(.data$NODFnull >= .data$obs_NODF) / nnull, .groups = 'drop')

    NODF_zsamples <- NODF_null %>%
      dplyr::group_by(.data$age, .data$sample) %>%
      dplyr::summarize(
        mean_NODF = mean(.data$NODFnull),
        sd_NODF = stats::sd(.data$NODFnull),
        .groups = 'drop'
      ) %>%
      dplyr::left_join(NODF_samples, by = c("age", "sample")) %>%
      dplyr::mutate(z = (.data$obs_NODF - .data$mean_NODF) / .data$sd_NODF) %>%
      dplyr::left_join(NODF_pvals, by = c("age", "sample"))

    ret <- as.data.frame(NODF_zsamples)
  }

  if (index == "Q") {

    Q_null <- Q_samples_null(sampled_networks, ages, nnull)
    Q_samples <- Q_samples_at_ages(sampled_networks, ages)

    Q_pvals <- Q_null %>%
      dplyr::filter(!is.na(Qnull)) %>%
      dplyr::left_join(Q_samples, by = c("age", "sample")) %>%
      dplyr::group_by(.data$age, .data$sample) %>%
      dplyr::summarise(p = sum(.data$Qnull >= .data$obs_Q) / nnull, .groups = 'drop')

    Q_zsamples <- Q_null %>%
      dplyr::group_by(.data$age, .data$sample) %>%
      dplyr::summarize(
        mean_Q = mean(.data$Qnull),
        sd_Q = stats::sd(.data$Qnull),
        .groups = 'drop'
      ) %>%
      dplyr::left_join(Q_samples, by = c("age", "sample")) %>%
      dplyr::mutate(z = (.data$obs_Q - .data$mean_Q) / .data$sd_Q) %>%
      dplyr::left_join(Q_pvals, by = c("age", "sample"))

    ret <- as.data.frame(Q_zsamples)
  }
  return(ret)
}


# Simulate null networks and calculate NODF
NODF_samples_null <- function(sampled_networks, ages, nnull, weighted = FALSE){
  index <- ifelse(weighted, 'weighted NODF', 'NODF')
  null_type <- ifelse(weighted, 'r00_both', 'r00')

  nsamp <- dim(sampled_networks[[1]])[1]

  NODF_null <- data.frame(
    age = rep.int(NA, nnull * nsamp * length(sampled_networks)), sample = NA, sim = NA, NODFnull = NA
  )

  for (a in seq_along(sampled_networks)) {
    for (i in seq_len(dim(sampled_networks[[a]])[1])) {
      net <- sampled_networks[[a]][i, , ]
      net <- net[rowSums(net) != 0, ]
      net <- net[, colSums(net) != 0]

      nullm <- vegan::nullmodel(net, null_type)
      sim <- stats::simulate(nullm, nsim = nnull)

      if(!is.vector(net)) {
        for (j in seq_len(nnull)) {
        Nrandom <- bipartite::networklevel(sim[, , j], index = index)
        NODF_null[(a - 1) * nsamp * nnull + (i - 1) * nnull + j, ] <- c(ages[a], i, j, Nrandom)
        }
      }
    }
  }

  NODF_null

}


# Get NODF for each sampled network
NODF_samples_at_ages <- function(sampled_networks, ages, weighted = FALSE){
  index <- ifelse(weighted, 'weighted NODF', 'NODF')

  nsamp <- dim(sampled_networks[[1]])[1]
  NODF_samples <- data.frame(
    age = rep.int(NA, nsamp * length(sampled_networks)), sample = NA, obs_NODF = NA
  )

  for (a in seq_along(sampled_networks)) {
    for (i in seq_len(dim(sampled_networks[[a]])[1])) {
      net <- sampled_networks[[a]][i, , ]
      net <- net[rowSums(net) != 0, ]
      net <- net[, colSums(net) != 0]

      if(!is.vector(net)) {
        nodf <- bipartite::networklevel(net, index = index)
        NODF_samples[(a - 1) * nsamp + i, ] <- c(ages[a], i, nodf)
      }
    }
  }

  NODF_samples

}

# Simulate null networks and calculate Q
Q_samples_null <- function(sampled_networks, ages, nnull){

  nsamp <- dim(sampled_networks[[1]])[1]
  Q_null <- data.frame(
    age = rep.int(NA, nnull * nsamp * length(sampled_networks)), sample = NA, sim = NA, Qnull = NA
  )

  for (a in seq_along(sampled_networks)) {
    for (i in seq_len(dim(sampled_networks[[a]])[1])) {
      net <- sampled_networks[[a]][i, , ]
      net <- net[rowSums(net) != 0, ]
      net <- net[, colSums(net) != 0]

      nullm <- vegan::nullmodel(net, "r00")
      sim <- stats::simulate(nullm, nsim = nnull)

      if(!is.vector(net)) {
        for (j in 1:nnull) {
          mod <- mycomputeModules(sim[, , j])
          Qrandom <- mod@likelihood
          Q_null[(a - 1) * nsamp * nnull + (i - 1) * nnull + j, ] <- c(ages[a], i, j, Qrandom)
        }
      }
    }
  }

  Q_null

}


# Get Q for each sampled network
Q_samples_at_ages <- function(sampled_networks, ages){

  nsamp <- dim(sampled_networks[[1]])[1]
  Q_samples <- data.frame(
    age = rep.int(NA, nsamp * length(sampled_networks)), sample = NA, obs_Q = NA
  )

  for (a in seq_along(sampled_networks)) {
    for (i in seq_len(dim(sampled_networks[[a]])[1])) {
      net <- sampled_networks[[a]][i,,]
      net <- net[rowSums(net) != 0, ]
      net <- net[, colSums(net) != 0]

      if(!is.vector(net)) {
        mod <- mycomputeModules(net)
        Q <- mod@likelihood
        Q_samples[(a - 1) * nsamp + i, ] <- c(ages[a], i, Q)
      }
    }
  }

  Q_samples

}
